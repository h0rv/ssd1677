//! Look-Up Tables (LUTs) for custom refresh waveforms
//!
//! The SSD1677 controller uses Look-Up Tables to define the waveform sequences
//! for updating the display. Custom LUTs can be loaded to enable:
//!
//! - **Faster refresh**: Trade quality for speed
//! - **Grayscale**: Partial update effects
//! - **Custom transitions**: Specific visual effects
//!
//! ## LUT Structure
//!
//! The SSD1677 LUT is 112 bytes (7 phases x 16 bytes each):
//!
//! - Phase 0: VCOM waveform
//! - Phase 1-4: Pixel transition waveforms (WW, BW, WB, BB)
//! - Phase 5: VCOM DC level
//! - Phase 6: Timing configuration
//!
//! ## Built-in LUTs
//!
//! - [`crate::lut::LUT_FAST`]: Fast refresh (~300ms), minimal flashing
//! - [`crate::lut::LUT_PARTIAL`]: Balanced quality/speed (~1720ms)
//! - [`crate::lut::LUT_GRAYSCALE`]: 4-level grayscale using both RAM planes
//! - [`crate::lut::LUT_CLEANUP`]: Transitions grayscale back to clean B/W
//!
//! ## Usage
//!
//! ```rust,no_run
//! use core::convert::Infallible;
//! use embedded_hal::delay::DelayNs;
//! use embedded_hal::digital::{InputPin, OutputPin};
//! use embedded_hal::spi::{Operation, SpiDevice};
//! use ssd1677::{Builder, Dimensions, Display, RefreshMode};
//! use ssd1677::lut::LUT_GRAYSCALE;
//!
//! # struct MockSpi;
//! # impl embedded_hal::spi::ErrorType for MockSpi { type Error = Infallible; }
//! # impl SpiDevice for MockSpi {
//! #     fn transaction(
//! #         &mut self,
//! #         _operations: &mut [Operation<'_, u8>],
//! #     ) -> Result<(), Self::Error> {
//! #         Ok(())
//! #     }
//! # }
//! # struct MockPin;
//! # impl embedded_hal::digital::ErrorType for MockPin { type Error = Infallible; }
//! # impl OutputPin for MockPin {
//! #     fn set_low(&mut self) -> Result<(), Self::Error> { Ok(()) }
//! #     fn set_high(&mut self) -> Result<(), Self::Error> { Ok(()) }
//! # }
//! # impl InputPin for MockPin {
//! #     fn is_high(&mut self) -> Result<bool, Self::Error> { Ok(false) }
//! #     fn is_low(&mut self) -> Result<bool, Self::Error> { Ok(true) }
//! # }
//! # struct MockDelay;
//! # impl DelayNs for MockDelay { fn delay_ns(&mut self, _ns: u32) {} }
//! # let spi = MockSpi;
//! # let dc = MockPin;
//! # let rst = MockPin;
//! # let busy = MockPin;
//! # let mut delay = MockDelay;
//! # let interface = ssd1677::Interface::new(spi, dc, rst, busy);
//! # let dims = match Dimensions::new(480, 800) {
//! #     Ok(dims) => dims,
//! #     Err(_) => return,
//! # };
//! # let config = match Builder::new().dimensions(dims).build() {
//! #     Ok(config) => config,
//! #     Err(_) => return,
//! # };
//! # let mut display = Display::new(interface, config);
//! # let black_buf = vec![0xFFu8; display.dimensions().buffer_size()];
//! # let red_buf = vec![0x00u8; display.dimensions().buffer_size()];
//! // Fast update with built-in LUT
//! let _ = display.update_with_mode(&black_buf, &red_buf, RefreshMode::Fast, &mut delay);
//!
//! // Or load custom LUT manually
//! let _ = display.load_lut(&LUT_GRAYSCALE);
//! let _ = display.update(&black_buf, &red_buf, &mut delay);
//! ```

/// LUT size in bytes for SSD1677
pub const LUT_SIZE: usize = 112;

/// Fast refresh LUT (~300ms, minimal ghosting)
///
/// Optimized for speed with single-phase transitions.
/// Best for: UI updates, scrolling, cursor movement.
///
/// Trade-offs:
/// - May have slight ghosting on high-contrast transitions
/// - Not suitable for images requiring full contrast
pub const LUT_FAST: [u8; LUT_SIZE] = [
    // Phase 0: VCOM
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 1: White -> White
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 2: Black -> White
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 3: White -> Black
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 4: Black -> Black
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 5: VCOM DC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 6: Timing
    0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

/// Partial/half refresh LUT (~1720ms, balanced quality)
///
/// Two-phase transitions for better contrast than fast refresh
/// while still being faster than full refresh.
/// Best for: Reading, page turns, moderate update frequency.
pub const LUT_PARTIAL: [u8; LUT_SIZE] = [
    // Phase 0: VCOM
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 1: White -> White (light pulse)
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 2: Black -> White
    0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 3: White -> Black
    0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 4: Black -> Black (light pulse)
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 5: VCOM DC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 6: Timing
    0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

/// Cleanup LUT for transitioning from grayscale to clean B/W
///
/// Use after grayscale operations to restore full contrast.
/// Three-phase transitions ensure complete pixel state reset.
pub const LUT_CLEANUP: [u8; LUT_SIZE] = [
    // Phase 0: VCOM
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 1: White -> White
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 2: Any -> White
    0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 3: Any -> Black
    0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 4: Black -> Black
    0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 5: VCOM DC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Phase 6: Timing
    0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

/// Grayscale LUT for fast refresh with 4 gray levels
///
/// This LUT enables partial grayscale rendering by defining transitions
/// for black, white, light gray, and dark gray. Useful for anti-aliased
/// text or dithered images.
///
/// ## Performance
///
/// - Update time: ~500ms
/// - Quality: Good for text, slight ghosting
/// - Use case: UI elements, frequent updates
pub const LUT_GRAYSCALE: [u8; 112] = [
    // Transition definitions (50 bytes)
    // Format: 10 bytes per transition group (L0-L4)
    // Each byte defines voltage phases for 4 pixel state transitions
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 00: black/white transition
    0x54, 0x54, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 01: light gray transition
    0xAA, 0xA0, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 10: gray transition
    0xA2, 0x22, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 11: dark gray transition
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // L4 (VCOM)
    // TP/RP timing groups (50 bytes)
    // 5 bytes per group: [TP_A, TP_B, TP_C, TP_D, RP]
    0x01, 0x01, 0x01, 0x01, 0x00, // G0: 4 frames
    0x01, 0x01, 0x01, 0x01, 0x00, // G1: 4 frames
    0x01, 0x01, 0x01, 0x01, 0x00, // G2: 4 frames
    0x00, 0x00, 0x00, 0x00, 0x00, // G3: 0 frames
    0x00, 0x00, 0x00, 0x00, 0x00, // G4: 0 frames
    0x00, 0x00, 0x00, 0x00, 0x00, // G5: 0 frames
    0x00, 0x00, 0x00, 0x00, 0x00, // G6: 0 frames
    0x00, 0x00, 0x00, 0x00, 0x00, // G7: 0 frames
    0x00, 0x00, 0x00, 0x00, 0x00, // G8: 0 frames
    0x00, 0x00, 0x00, 0x00, 0x00, // G9: 0 frames
    // Frame rate (5 bytes)
    0x8F, 0x8F, 0x8F, 0x8F, 0x8F, // Voltages: VGH, VSH1, VSH2, VSL, VCOM (5 bytes)
    0x17, 0x41, 0xA8, 0x32, 0x30, // Reserved (2 bytes)
    0x00, 0x00,
];

/// Grayscale revert LUT for fast refresh
///
/// Similar to [`LUT_GRAYSCALE`] but with different transition definitions
/// that may provide better quality for certain display panels.
///
/// ## Performance
///
/// - Update time: ~500ms
/// - Quality: Similar to LUT_GRAYSCALE
/// - Use case: Alternative grayscale mode
pub const LUT_GRAYSCALE_REVERT: [u8; 112] = [
    // Transition definitions (50 bytes)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 00: black/white
    0x54, 0x54, 0x54, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 10: gray
    0xA8, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 01: light gray
    0xFC, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 11: dark gray
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // L4 (VCOM)
    // TP/RP timing groups (50 bytes)
    0x01, 0x01, 0x01, 0x01, 0x01, // G0
    0x01, 0x01, 0x01, 0x01, 0x01, // G1
    0x01, 0x01, 0x01, 0x01, 0x00, // G2
    0x01, 0x01, 0x01, 0x01, 0x00, // G3
    0x00, 0x00, 0x00, 0x00, 0x00, // G4
    0x00, 0x00, 0x00, 0x00, 0x00, // G5
    0x00, 0x00, 0x00, 0x00, 0x00, // G6
    0x00, 0x00, 0x00, 0x00, 0x00, // G7
    0x00, 0x00, 0x00, 0x00, 0x00, // G8
    0x00, 0x00, 0x00, 0x00, 0x00, // G9
    // Frame rate (5 bytes)
    0x8F, 0x8F, 0x8F, 0x8F, 0x8F, // Voltages (5 bytes)
    0x17, 0x41, 0xA8, 0x32, 0x30, // Reserved (2 bytes)
    0x00, 0x00,
];
